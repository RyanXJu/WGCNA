# **  WGCNA pipeline part 4:   **

# choose module and trait of interest to analyze

# ###### input: ###########################################################
# network.Rdata generated by WGCNA_part3.R
###########################################################################


## module load R/3.6.1
.libPaths("/u/juxiao/R/x86_64-pc-linux-gnu-library/3.6" )
.libPaths()

cat("\n
    *********************************\n
    *********  WGCNA part4  *********\n
    ******* Module Analysis  ********\n
    *********************************")

library(ggplot2)
library(gplots)
library(reshape2)
library(doParallel)
library(WGCNA)
library(biomaRt)
library(topGO)
# BiocManager::install("KEGGREST")
library(KEGGREST)
options(stringsAsFactors = FALSE)


cat("Enter working directory \nLocation of \"network.RData\": ")
directory <- readLines("stdin", 1)

setwd(file.path(directory))
getwd()


geneID.sel <- ""  
module.sel <- ""
trait.sel <- ""

############### load data ###########################################################
netInfo <- load("network.RData")
# netInfo

## user enter : geneID type (since KEGGREST can only take symobl, this info is needed to convert geneids later)
cat("\n--------------- Confirm the geneID type used in the expression data : ---------------- \n")
cat("\nThis pipeline can only take \n [1]\"ensembl_gene_id\" 
    \n [2]\"ensembl_gene_id_version\" 
    \n [3]\"hgnc_symbol\" \n")
geneID.type.list = c("ensembl_gene_id", "ensembl_gene_id_version", "hgnc_symbol")
while (!(geneID.sel %in% c(1:3))) {
  cat("Enter the number of expression data geneID type : ")
  geneID.sel <- readLines("stdin", 1)
  if (!(geneID.sel %in%  c(1:3))) { cat("The geneID type is not supported, please choose 
                                         \n [1] for \"ensembl_gene_id\" 
                                         \n [2] for \"ensembl_gene_id_version\"
                                         \n [3] for \"hgnc_symbol\"")}
  geneID.type <<- geneID.type.list[as.integer(geneID.sel)]
}
# geneID.type


## user enter : color of module of intrest
cat("\n---------------Number of genes in each module: ---------------- \n")
print(as.data.frame(table(moduleColors)))

while (!(module.sel %in% unique(moduleColors))) {
  cat("Enter the color of the module: ")
  module.sel <- readLines("stdin", 1)
  if (!(module.sel %in% unique(moduleColors))) { cat("The entered color module does'nt exist, please Enter a color\n")}
}


## user enter : trait of intrest
cat("\n---------------Traits : ---------------- \n")
print(colnames(datTraits))

while (!(trait.sel %in% colnames(datTraits))) {
  cat("Enter the trait of intrest: ")
  trait.sel <- readLines("stdin",1)
  if (!(trait.sel %in% colnames(datTraits))) { cat("The entered trait does'nt exist, please Enter a trait\n")}
}


trait <- as.data.frame(datTraits[,trait.sel])
names(trait) <- trait.sel


############### Eigengene + trait dendrogram
MET = orderMEs(cbind(MEs, trait))

pdf("Part4_eigengeneTraitDendrogram.pdf", width=12, height=8)
par(mar = c(6, 6, 3, 3))
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2),
                      marHeatmap = c(5,4,1,2), cex.lab = 0.8,
                      xLabelsAngle= 90)
dev.off()


############### Gene Module Membership ##############################################
cat("\n----------------- Calculate gene ModuleMembership --------------------\n")
nGenes = ncol(datExpr2)
nSamples = nrow(datExpr2)
geneModuleMembership = as.data.frame(cor(datExpr2, MEs, use = "p"))  # correlation of the gene and the ME
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership),  nSamples))

modNames = gsub("ME","",colnames(MEs))
names(geneModuleMembership) = paste("MM", modNames, sep="")
names(MMPvalue) = paste("p.MM", modNames, sep="")


################ GS: Gene Significance ###############################################
cat("\n----------------- Calculate gene significance for the chosen trait ----\n")

geneTraitSignificance = as.data.frame(cor(datExpr2, trait, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), dim(datTraits)[1]))

colnames(geneTraitSignificance) = paste("GS.", trait.sel, sep="")
colnames(GSPvalue) = paste("p.GS.", trait.sel, sep="")

geneInModule.mm = data.frame( "MM" = geneModuleMembership[ moduleColors==module.sel , paste0("MM", module.sel, sep="")],
                              "p.MM" = MMPvalue[ moduleColors==module.sel , paste0("p.MM", module.sel, sep="")],
                              "GS" = geneTraitSignificance [ moduleColors==module.sel , paste("GS.", trait.sel, sep="")],
                              "p.GS" = GSPvalue[ moduleColors==module.sel , paste("p.GS.", trait.sel, sep="")])
rownames(geneInModule.mm) <- rownames(geneModuleMembership)[ moduleColors==module.sel]


plotname = paste("Part4_geneInModule_",module.sel,".pdf", sep="")
pdf(plotname, width=12, height=8)
par(mar = c(6, 6, 3, 3))
verboseScatterplot(abs(geneModuleMembership[ moduleColors==module.sel , paste0("MM", module.sel, sep="")]),
                   abs(geneTraitSignificance[moduleColors==module.sel, 1]),
                   xlab = paste("Module Membership (gene module cor) in", module.sel, "module"),
                   ylab = paste("Gene significance (gene trait cor) for ", trait.sel, sep = ""),
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module.sel)
dev.off()


# genes in the selected module
geneInModule <- colnames(datExpr2)[moduleColors == module.sel]
# geneInModule


# verify geneID type, build annotation dataframe
geneAnn<- getBM(attributes=c('ensembl_gene_id_version', 
                             'ensembl_gene_id', 
                             'hgnc_symbol',
                             'entrezgene_id'), 
                filters = geneID.type, 
                values = colnames(datExpr2), 
                mart = useMart("ensembl",dataset="hsapiens_gene_ensembl")
                # mart = useMart("ensembl", dataset = "mmusculus_gene_ensembl")  # for mouse
                )
# geneAnn


# 
geneInModule.Ann = geneAnn[match(geneInModule,geneAnn[[geneID.type]]),]
geneInModule.df = merge(geneInModule.Ann, geneInModule.mm, by.x ="ensembl_gene_id_version" ,  by.y = "row.names" )

write.table(geneInModule.df, file = paste0(paste("geneInModule",module.sel,trait.sel,sep="_"), ".tsv"), 
            quote = FALSE, col.names=NA, sep="\t" )



######################### GO term enrichment analysis ########################
cat("\n ---------------GO enrichment analysis of module : ---------------- \n")

all_genes <- geneAnn$ensembl_gene_id

geneList <- factor(as.integer (geneAnn[[geneID.type]] %in% geneInModule))
# geneList
names (geneList) <- all_genes

geneSelFunc <- function (x) {
  return(x == 1 )
}

# Create topGOData object (topGO can use EnsemblID or Symbol)
GOdata <- new("topGOdata",
              ontology = "BP",
              allGenes = geneList,
              geneSelectionFun = geneSelFunc,
              nodeSize = 5,
              annot = annFUN.org, 
              mapping = "org.Hs.eg.db",
              # mapping="org.Mm.eg.db", # for mouse
              ID = "Ensembl")  # ID = c("symbol", "Ensembl")

# retrieve genes2GO list from the "expanded" annotation in GOdata
allGO = genesInTerm(GOdata)
resultKS <- runTest(GOdata, algorithm = "classic", statistic = "fisher") 
# algorithm can be :  "classic", "elim", "weight01"
# statistic can be : "fisher", "ks"

tab <- GenTable(GOdata, raw.p.value = resultKS, topNodes = length(resultKS@score), numChar = 120)
print(head(tab, 10))


######################### KEGG  #################################################
cat("\n ---------------KEGG analysis of module : ---------------- \n")

# all databases
# listDatabases()
# keggList("organism")
# keggList("hsa")

# Pull all pathways for AT
pathways.list <- keggList("pathway", "hsa")
# pathways.list <- keggList("pathway", "mmu") # for mouse
# head(pathways.list)

# Pull all genes for each pathway
pathway.codes <- sub("path:", "", names(pathways.list))
names(pathways.list) <- pathway.codes
genes.by.pathway <- sapply(pathway.codes,
                           function(pwid){
                             pw <- keggGet(pwid)
                             if (is.null(pw[[1]]$GENE)) return(NA)
                             pw2 <- pw[[1]]$GENE[c(FALSE, TRUE)] # may need to modify this to c(FALSE, TRUE) for other organisms
                             pw2 <- unlist(lapply(strsplit(pw2, split = ";", fixed = T), function(x)x[1]))
                             return(pw2)
                           }
)
# head(genes.by.pathway)

geneList_KEGG <- geneModuleMembership[geneInModule, paste0("MM", module.sel, sep="")]
names(geneList_KEGG) <- geneAnn$hgnc_symbol[match(geneInModule, geneAnn[[geneID.type]] )]
# head(geneList_KEGG)

# Wilcoxon test for each pathway
pVals.by.pathway <- t(sapply(names(genes.by.pathway),
                             function(pathway) {
                               # print(pathway)
                               pathway.genes <- genes.by.pathway[[pathway]]
                               
                               if (is.na(pathway.genes[1])){
                                 p.value <- NA
                                 list.genes.in.pathway <- 0
                               }
                               
                               else{
                                 list.genes.in.pathway <- intersect(names(geneList_KEGG), pathway.genes)
                                 list.genes.not.in.pathway <- setdiff(names(geneList_KEGG), list.genes.in.pathway)
                                 scores.in.pathway <- geneList_KEGG[list.genes.in.pathway]
                                 scores.not.in.pathway <- geneList_KEGG[list.genes.not.in.pathway]
                                 
                                 if (length(scores.in.pathway) > 0){
                                   p.value <- wilcox.test(scores.in.pathway, scores.not.in.pathway, alternative = "less")$p.value
                                 }
                                 else{
                                   p.value <- NA
                                 }
                               }
                               
                               return(c(p.value = p.value , Annotated = length(list.genes.in.pathway)))
                             }
))

# Assemble output table
outdat <- data.frame(pathway.code = rownames(pVals.by.pathway))
outdat$pathway.name <- pathways.list[outdat$pathway.code]
outdat$p.value <- pVals.by.pathway[,"p.value"]
outdat$Annotated <- pVals.by.pathway[,"Annotated"]
outdat <- outdat[order(outdat$p.value),]
print(head(outdat,10))

cat("\n--------------------- Part4 Done -----------------------------\n")
